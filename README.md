# HuaWeibei
华中科技大学计算机学院硕士3班参赛组
参赛队员：朱寒冰、刘衡、周鑫宜

## 初赛
### 第一天 处理输入以及初步整理思路
初读题目之后，针对输入的数据如何存储，定义如下的数据结构：
1、首先剔除无用的信息：因为输出是跟输入文件的时刻顺序相同的，因此时刻具体指什么时间无关紧要，我们仅仅用一个索引来体现他是对应时刻即可
2、所有的客户节点都有一个名称（题目中的ID）和编号（数字），名称和编号是一一对应的。在实际计算的过程中，我们只需要他的编号即可，只有在最后输出的时候才需要对应名称（ID）。为了保险起见，定义一个unordered_map<string,int>实现名称到编号的转换，以及一个vector\<string>实现编号到名称的转换。
3、每个客户节点在一个时刻都有一个带宽的需求（需求可能为0）。定义一个vector<vector\<int>> demand，demand[i][j]表示的是第i个时间第j个客户节点的需求。
4、对于边缘节点，同样赋予其名称和编号。此处使用的数据结构为unordered_map<string,int>表示名称到编号的转化。以及定义一个vector\<pair<string,int>>，表示第i个节点的名称（ID）以及最大带宽BandWidth
5、客户到边缘节点存在着时延，用vector\<vector\<int>>表示第i个客户节点到第j个边缘节点的时延
6、QOS直接从config.ini进行读取即可
7、输入处理结束之后，实现名称到编号转换的两个map都可以删除


初步的思路整理：
由于单位带宽的成本就是1，因此我们需要最小化的就是所有边缘节点的95百分位带宽之和。因此我们希望的是95百分位带宽越小越好。95百分位带宽意味着存在5%的时刻，当前节点的带宽需求可以非常大(只要不超过带宽限制即可)。因此个人初步的思路就是贪心：对于每个节点，我们都尽量找5%（此处是向下取整，因为最后的结果是向上取证）的时间，他的带宽越高越好，然后剩下的时间，他的带宽越低越好（就是剩下时间的最大值要尽可能小）。

初步思路有如下的限制：
限制：对于每个边缘节点，有一部分的客户节点是无法被他服务的。


## 复赛
### 第一天 处理输入以及基本整理思路
针对输入的数据如何存储，定义的数据结构类型与初赛基本一致，只是分为多个文件编写方便修改和查阅等
1、将初赛中demand数据结构修改为vector<vector\<unordered_map\<string,int>>>类型，最外层表示的是每个不同的时刻，中间表示不同的client，最内层的unordered_map则表示流ID->数据

### 4月7日
1、目前利用5%的策略：
（1）在线练习最优：将所有流（包括0）从大到小排序，选择某个百分位节点（可调参）为阈值。将边缘节点按照某种排序策略进行排序（可调整），然后针对每个边缘节点，根据其周围所有大于阈值之和的天数进行排序，然后优先选择前5%的天数使用他的次数。使用次数的过程中，采用周围流从大到小的方式依次满足。
（2）线下最优：在（1）的基础上，将节点的次数分为2批次使用。
（3）方案1：对于周围流总数大于边缘节点上限的天数，应该平等对待，按照最大流从大到小进行排序
（4）方案2：对于周围流总数大于边缘节点上限的天数，应该平等对待，按照sum(从大到小排序的流)达到边缘节点上限的个数从小到大排序。